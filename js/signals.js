// Trading Signals Generator using Gemini API
// Displays signals on the frontend

const SIGNALS_API = '/api/generate-signals'; // Your backend endpoint

async function loadSignals() {
    const container = document.getElementById('signals-container');
    
    try {
        // Fetch pre-generated signals (generated by GitHub Actions daily)
        const response = await fetch('data/signals.json');
        const signals = await response.json();
        
        var isVip = window.entitlements && window.entitlements.any(['vip','monthly','yearly']);
        container.innerHTML = signals.slice(0, 3).map(signal => `
            <div class="signal-card ${signal.direction}">
                <div class="signal-pair">${signal.pair}</div>
                <div class="signal-direction ${signal.direction}">
                    ${signal.direction === 'buy' ? 'ðŸ“ˆ BUY' : 'ðŸ“‰ SELL'}
                </div>
                <div class="signal-details">
                    <p><strong>Entry:</strong> ${signal.entry}</p>
                    ${isVip && signal.tp ? `<p><strong>Take Profit:</strong> ${signal.tp}</p>` : `<p class="blurred"><strong>Take Profit:</strong> VIP Only</p>`}
                    ${isVip && signal.sl ? `<p><strong>Stop Loss:</strong> ${signal.sl}</p>` : `<p class="blurred"><strong>Stop Loss:</strong> VIP Only</p>`}
                </div>
                <div class="signal-time">Posted: ${signal.time}</div>
            </div>
        `).join('');
        
    } catch (error) {
        container.innerHTML = `
            <div class="signal-card">
                <p>ðŸ“Š Signals updating... Check back soon!</p>
            </div>
        `;
    }
}

// Countdown timer
function updateCountdown() {
    const now = new Date();
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0);
    
    const diff = midnight - now;
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((diff % (1000 * 60)) / 1000);
    
    document.getElementById('countdown').textContent = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    loadSignals();
    setInterval(updateCountdown, 1000);
    var toggle = document.getElementById('signals-alert-toggle');
    if (toggle) {
        var enabled = localStorage.getItem('notifications_enabled') === 'true';
        toggle.checked = enabled;
        toggle.addEventListener('change', function() {
            if (toggle.checked) {
                if (Notification.permission === 'default') {
                    Notification.requestPermission().then(function(permission) {
                        if (permission === 'granted') {
                            localStorage.setItem('notifications_enabled', 'true');
                        } else {
                            toggle.checked = false;
                        }
                    });
                } else if (Notification.permission === 'granted') {
                    localStorage.setItem('notifications_enabled', 'true');
                } else {
                    alert('Notifications are blocked. Enable them in your browser settings.');
                    toggle.checked = false;
                }
            } else {
                localStorage.setItem('notifications_enabled', 'false');
            }
        });
    }
});
